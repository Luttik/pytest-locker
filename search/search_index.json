{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyTest-Locker \u00b6 PyTest-Locker: The fastest way to check for unexpected changes between test runs The general concept \u00b6 In essense Pytest-Locker changes the basis of testing from having to assert everything that is relevant about an object to only having to assert that an object should not change unexpectedly (i.e. the object is locked). This, of course, implies that the pytest-locker approach makes a lot of sense when the assertion logic becomes complex. I found it especially handy when testing if I'm sending the right API calls. Since objects can be just about anything in python (output, state, or even function calls via mocking ) you can use this approach for just about everything. Since you need to validate if the object to lock is correct, both in the first run and after desired modifications, the test flow is slightly different: Why use PyTest-Locker \u00b6 Time efficient: No need to hard code expected responses. (Especially usefull for data heavy unittests) Easy to verify changes: Seperates the logic of the test from the expected values. The lock files (containing the expected values), and changes to them, are easy to interpret. This makes it really simple to evaluate changes during testing, in commits and in pull request. Install \u00b6 run pip install pytest-locker Usage \u00b6 Configuring the project and writing your first test. \u00b6 Add from pytest_locker import locker to your conftest.py file To access the locker by adding it to the method parameters i.e. def test_example(locker) Use locker.lock(your_string, optional_name) to lock the data (of-course you can also lock other types). Ensure that the pytest rootdir is fixed. See the pytest customize documentation for all the options (one is adding a pytest.ini to the root folder) Ensure that .pytest_locker/ is synced via git, to ensure that you, your team, and your CI/CD pipelines are working with the same data. And you're all set! Accepting the current behavior and checking fo changes in this behavior \u00b6 There are two modes based on for locking. The first is When user input is allowed, i.e. when running pytest with --capture no or -s When user input is allowed and the given data does not correspond to the data in the lock the user is prompted if the new data should be stored or if the tests should fail. When user input is captured which is default behavior for pytest If user input is not allowed the tests will automatically fail if the expected lock file does not exist or if the data does not correspond to the data in the lock file. The Locker class \u00b6 You can also use pytest_locker.Locker (i.e. the class of which the locker fixture returns an instance) directly to create fixtures that locks a (non-string) object without needing to turn the object into a string it. Examples \u00b6 For example of use look at the tests in repr-utils .","title":"PyTest-Locker"},{"location":"#pytest-locker","text":"PyTest-Locker: The fastest way to check for unexpected changes between test runs","title":"PyTest-Locker"},{"location":"#the-general-concept","text":"In essense Pytest-Locker changes the basis of testing from having to assert everything that is relevant about an object to only having to assert that an object should not change unexpectedly (i.e. the object is locked). This, of course, implies that the pytest-locker approach makes a lot of sense when the assertion logic becomes complex. I found it especially handy when testing if I'm sending the right API calls. Since objects can be just about anything in python (output, state, or even function calls via mocking ) you can use this approach for just about everything. Since you need to validate if the object to lock is correct, both in the first run and after desired modifications, the test flow is slightly different:","title":"The general concept"},{"location":"#why-use-pytest-locker","text":"Time efficient: No need to hard code expected responses. (Especially usefull for data heavy unittests) Easy to verify changes: Seperates the logic of the test from the expected values. The lock files (containing the expected values), and changes to them, are easy to interpret. This makes it really simple to evaluate changes during testing, in commits and in pull request.","title":"Why use PyTest-Locker"},{"location":"#install","text":"run pip install pytest-locker","title":"Install"},{"location":"#usage","text":"","title":"Usage"},{"location":"#configuring-the-project-and-writing-your-first-test","text":"Add from pytest_locker import locker to your conftest.py file To access the locker by adding it to the method parameters i.e. def test_example(locker) Use locker.lock(your_string, optional_name) to lock the data (of-course you can also lock other types). Ensure that the pytest rootdir is fixed. See the pytest customize documentation for all the options (one is adding a pytest.ini to the root folder) Ensure that .pytest_locker/ is synced via git, to ensure that you, your team, and your CI/CD pipelines are working with the same data. And you're all set!","title":"Configuring the project and writing your first test."},{"location":"#accepting-the-current-behavior-and-checking-fo-changes-in-this-behavior","text":"There are two modes based on for locking. The first is When user input is allowed, i.e. when running pytest with --capture no or -s When user input is allowed and the given data does not correspond to the data in the lock the user is prompted if the new data should be stored or if the tests should fail. When user input is captured which is default behavior for pytest If user input is not allowed the tests will automatically fail if the expected lock file does not exist or if the data does not correspond to the data in the lock file.","title":"Accepting the current behavior and checking fo changes in this behavior"},{"location":"#the-locker-class","text":"You can also use pytest_locker.Locker (i.e. the class of which the locker fixture returns an instance) directly to create fixtures that locks a (non-string) object without needing to turn the object into a string it.","title":"The Locker class"},{"location":"#examples","text":"For example of use look at the tests in repr-utils .","title":"Examples"}]}